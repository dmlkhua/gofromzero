# Цикли

> Цикли це інструмент для виконання одного блоку коду декілька раз

Розглянемо найпростіший варіант цикла:
```golang
for i := 0; i < 10; i++ {
    fmt.Print(i, " ")
}
```
Програма виведе на екран: `0 1 2 3 4 5 6 7 8 9`

Розберемо в деталях компоненти цикла:
```
ДО ЦИКЛУ
for СТВОРИТИ СТАН; ПЕРЕВІРКА СТАНУ; ЗМІНА СТАНУ {
    ТІЛО ЦИКЛУ
}
ПІСЛЯ ЦИКЛУ
```

Ітерація - це виконання тілу цикла один раз

На початку цикла виконується блок "СТВОРИТИ СТАН", де ми можемо, хоча не забов'язані, створити нову змінну.
Наступний запис також буде правилним і за своїм результатом не буде відрізнятись від попереднього прикладу:
```
i := 0
for ; i < 10; i++ {
    fmt.Print(i, " ")
}
```

Однак невиличка різниця а даному коді все ж таки є. Щоб зрозуміти її, подивимось на наступні 2 приклади:
1:
```golang
for i := 0; i < 5; i++ {
    fmt.Print(i, " ")
}
fmt.Println(i)
```
2:
```golang
i := 0
for ; i < 5; i++ {
    fmt.Print(i, " ")
}
fmt.Println(i)
```

Приклад №1 не запуститься з помилкою про те, що на останній строчці змінної `i` не існує. Тобто, коли змінна створюється в блоці цикла "СТВОРИТИ СТАН", вона існує лише у межах цикла.

Блок "ЗМІНА СТАНУ" викликається кожен раз після виконання ТІЛА ЦИКЛУ і також не є обов'язковим
Наступний запис також буде правилним і за своїм результатом не буде відрізнятись від самого першого прикладу:
```golang
i := 0
for ; i < 10; {
    fmt.Print(i, " ")
    i++
}
```

Блок "ПЕРЕВІРКА СТАНУ" виконується одразу після блоку "ЗМІНА СТАНУ". Він також не є обов'язковим.
Запис нижче за своїм результатом не буде відрізнятись від інших прикладів:
```golang
i := 0
for {
    fmt.Print(i, " ")
    i++
    if i == 10 {
        break
    }
}
```
Ключове слово "break" використовується для припинення дії циклу. Тобто ми при пиняємо дію циклу, коли значення i дорівнює 10. break переміщую виконання програми на блок ПІСЛЯ ЦИКЛУ.
Але слід зауважити, що break запиную лише той цикл, в тілі котрого він написаний, тобто:
```golang
for i := 0; i < 3; i++ {
    fmt.Printf("i=%d ", i)
    for j := 0; j < 3; j++ {
        fmt.Printf("j=%d ", i)
        break
        fmt.Print("j:end")
    }
    fmt.Printf("i:end ", i)
    fmt.Println()
}
```
Результатом данної програми буде:
```
i=0 j:0 i:end
i=1 j:0 i:end
i=2 j:0 i:end
```
Внутрішній цикл ніколи не перейде на другу ітерацію (там де j=1), томущо break буде виконаний безумовно, тобто на першій ітерації.

В блоці ПЕРЕВІРКА СТАНУ може бути будь який вираз або змінна булевого типу:
```golang
b := true
for i := 0; b; i++  {
    if i >= 5 {
        b = false
    }
}
```
В прикладі вище, на шостій ітерації, коли `i` стане дорівнювати 5, виконається умова і змінній `b` буде присвоєно значення false. Оскільки `b` використовується як єдина умова в блоці цикла ПЕРЕВІРКА СТАНУ, то після цієї шостої ітерації цикл завершиться.

При роботі з циклами ми можемо також використовувати ключове слово `continue`, що дозволяє перейти до наступної ітерації
```golang
for i := 0; i <= 5; i++ {
    if i % 2 == 0 {
        continue
    }
    fmt.Print(i, " ")
}
```
Результат буде наступний: `1 3 5`

Весь код, що розташований в тілі цикла після `continue` виконаний не буде, натомість виконання програми перейде одразу до ЗМІНИ СТАНУ.
Тому варто бути обережним, наприклад наступний код ніколи не завершиться:
```golang
i := 1
for ; i <= 5; {
    if i % 3 == 0 {
        continue
    }
    fmt.Print(i, " ")
    i++
}
```
В цьому прикладі на 2 ітерації буде виконана умова  тобто `2 % 2 == 0` і виконання перейде до блоку цикла ЗМІНА СТАНА, але оскільки цей блок ми залишили пустим то `i` ніколи не буде збільшено і на наступній ітерації буде виконана та сама переверка, яка видасть той самий результат.

## Матриці
Приклад створення матриці 5x5, крайні ячейкі котрої заповнені 5, а інші 1:
```golang
package main

import "fmt"

func main() {
	matrix := make([][]int, 5)

	for i := 0; i < len(matrix); i++ {
		matrix[i] = make([]int, 5)
		for j := 0; j < len(matrix[i]); j++ {
			if i == 0 || j == 0 || i == len(matrix)-1 || j == len(matrix[i])-1 {
				matrix[i][j] = 5
			} else {
				matrix[i][j] = 1
			}
		}
	}

	showMatrix(matrix)
}

func showMatrix(matrix [][]int) {
	for i := 0; i < len(matrix); i++ {
		for j := 0; j < len(matrix[i]); j++ {
			fmt.Print(matrix[i][j], " ")
		}
		fmt.Println()
	}
}
```

Приклад перемноження матриць
```golang
package main

import "fmt"

func main() {
	matrix1 := [][]int{
		{5, 54, 4, 9},
		{16, 2, 11, 6},
		{15, 43, 8, 9},
		{13, 6, 7, 94},
	}

	matrix2 := [][]int{
		{15, 7, 81, 3},
		{9, 6, 12, 19},
		{3, 24, 9, 8},
		{7, 32, 5, 9},
	}

	newMatrix := make([][]int, len(matrix1))

	for i := 0; i < len(matrix1); i++ {
		newMatrix[i] = make([]int, len(matrix1[i]))
		for j := 0; j < len(matrix1[i]); j++ {
			newMatrix[i][j] = matrix1[i][j] * matrix2[i][j]
		}
	}

	showMatrix(newMatrix)
}

func showMatrix(matrix [][]int) {
	for i := 0; i < len(matrix); i++ {
		for j := 0; j < len(matrix[i]); j++ {
			fmt.Print(matrix[i][j], " ")
		}
		fmt.Println()
	}
}

```
