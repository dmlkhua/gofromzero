# Функції

> Функція - це ділянка коду, що має назву і яка може бути виконана "по виклику" з інших частин програми

> Використання функції дозволяє розбивати складні завдання на більш дрібні та прості, що кардинально знижує загальну складність програми. Наприклад, якщо ви працюєте в команді, один з учасників команди може створити функцію, а інші будуть її використовувати. 

## Створення функції

### Схема функції

```
func НАЗВА ФУНКЦІЇ(АРГУМЕНТИ) ТИП ЗНАЧЕННЯ ЩО ПОВЕРТАЄТЬСЯ {
    ТІЛО ФУНКЦІЇ
}
```
де аргументи та тип значення що повертається є опціональними

Перший приклад - проста функція (без аргументів та типу значення що повертається)
```golang
func sayHello() {
    fmt.Println("Hello!")
}
```

Другий приклад - функція з аргументами, але без типу значення що повертається
```golang
func sayHello(name string) {
    fmt.Println("Hello ", name)
}
```

Третій приклад - функція з аргументами та з типом значення що повертається
```golang
func getGreeting(name string) string {
    return "Hello " + name
}
```
в цьому прикладі ми бачимо ключове слово `return`, котра містить кожна функція, що має тип значення що повертається

### Правила створення функції

1) Назва функції підлягає тим самим правилам, що і назва змінних, тобто вона не може починатися з цифри та `_` та може містити лише наступні символи: `a-z`, `A-Z`, `_`, `0-9`. 

Назва функції має означати суть того, що виконує функція. Це потрібно для того, щоб людина, котра викликає функція, що була написана кимось іншим могла зрозуміти призначення цієї функції за її назвою.

> Символ `_` називається underscore ("андерскор")

2) Не можна створювати змінні з іменами, котрі уже зайняті іменами функцій, наприклад:

```golang
package main

func main() {
    doNothing := 0 // panic! - створення змінної `doNothing` конфліктує з такою самою назвою функції
}

func doNothing() {
    // ця функція нічого не робить
}
```

3) Функція не може бути створена всередині іншої функції, тобто наступний код не є вірним:
```golang
package main

func main() {
    func doNothing() {
        //
    }
}
```

### Терміни функції

**Визначення функції** це її назва + аргументи + тип значення, що повертається, наприклад `func getGreeting(name string) string` або `func sayHello()`

**Викликати функцію** означає запустити виконання коду, що написаний в блоці ТІЛО ФУНКЦІЇ. Функція може бути викликана безліч разів. Якщо програма не викликає функцію її ТІЛО ніколи не буде виконано.

**Аргументи** це дані котра фунція опрацьовує. 

Кожен аргумент має ім'я та тип даних, наприклад в коді `func sumTwoNumbers(a int, b int)` `a int` та `b int` є аргументами. 

Ми можемо подивитись на аргументи з двої різних перспектив:

- з перспективи людини, що створює функцію, аргументи - це її потреби/очікування. Тобто коли ми пишемо функцію для виводу привітання в консоль, ми зазначаємо, що для виклику даної функції необхідно передати аргумент `name`, тобто ім'я людини, котру ми будемо вітати
- з перспективи людини, котра хоче використати функцію, написану кимось іншим аргументи це значення, котрі ми маємо передати функції для її коректної роботи; з цієї перспективи аргумент це просто змінна; з цієї песпективи назва аргумента домопагає зрозуміти суть функції і є такою важливою частиною, як і сама назва функції.

**Тип значення що повертається** це тип даних котрий використовується функцією для повернення результату виклика функції

**Тіло функції** це весь код, розташований поміж `{` та `}`

> кожна програма містить функцію `main` - це особлива функція, вона є точкою входу в програму, тобто місце, з котрого програма починає своє виконання. Ця функція викликається самим Go.

## Приклади

### Приклад 1

```golang
package main 

func main() {
    sayHello("Anna") // виклик функції
    sayHello("Dmytro") // виклик функції
}

func sayHello(name string) {
    fmt.Println("Hello ", name)
}
```
Результатом виконання програми буде:
```
Hello Anna
Hello Dmytro
```

В даному прикладі ми можемо сказати, що була створена функція, призначення котрої виводити привітання в консоль.

Дана функція має назву `sayHello` і вона приймає один аргументом `name string`. 

Функція була викликана з тіла функції `main` два рази, перший раз з аргументом "Anna", другий - з аргументом "Dmytro". Коли ми кажемо що функція була викликана з певним аргументом, ми маємо на увазі, що аргумент, що міститься в визначенні функції тобто `name string` набув значення "Anna" `(var name string = "Anna")`.


### Приклад 2

```golang
package main 

func main() {
    annaGreeting := getGreeting("Anna")
    fmt.Println(annaGreeting)
    dmytroGreeting := getGreeting("Dmytro")
    fmt.Println(dmytroGreeting)
}

func getGreeting(name string) string {
    return "Hello " + name
}
```
Результатом виконання програми буде:
```
Hello Anna
Hello Dmytro
```
В даному прикладі функція `getGreeting` викликається 2 рази, один раз з аргументом "Anna", інший - з аргументом "Dmytro".

Розберемо детально виклик функції `annaGreeting := getGreeting("Anna")`.

Оператор `:=` відповідає за створення нової змінної. По ліву частину цього оператор записана назва змінної, що буде створена. По праву частину - вираз, що буде обчислений і результат котрого буде значенням нової змінної.
В нашому випадку в якості виразу ми маємо виклик фунції `getGreeting("Anna")`. Так як ця функція повертає значення, то саме це значення буде записано як значення новоствореної змінної. Тобто змінна `annaGreeting` буде мати значення "Hello Anna".

### Приклад 3
```golang
package main

func main() {
    price := calculatePeachPrice(10)
    fmt.Println(price)
}

func calculatePeachPrice(number int) float64 {
    var price float64
    if number < 10 {
        price = 3.20
    } else if number < 20 {
        price = 2.90
    } else if number < 30 {
        price = 2.40
    } else {
        price = 2.15
    }
    return price
}
```
В даному приклади ми створили функцію для визначення ціни на персики по кількості. Ми ще можемо сказати, що ми "інкапсулювали" логіку для визначення ціни в окрему функцію.

З точки зору людини, що викликає функцію, нам не потрібно знати як розраховується  ціна на персики, просто подивившись на визначення функції `calculatePeachPrice(number int) float64` ми можемо зрозуміти, що вона робить по її назві. Ми також можемо зрозуміти, що в якості аргументи ця функція очікує кількість персиків `number`, а результатом роботи функції є ціна за один персик (`float64`).

Іноді функції можуть містити дуже складну логіку, котра для людини, що її викликає не буде мати жодного сенсу. В таких випадках саме визначення функції є ключовим інструментом для розуміння того, яка роль цієї функції.

Ми також можемо мати ситуацію, коли певний пакет (про це пізніше) містить купу різних функцій. В такому разі визначення функції домопоже знайти саме ту, котра нам потрібна.

Часто, коли логіка функції занадто складна, ми можемо додати коментарій до функції:
```golang
// calculatePeachPrice - розраховує ціну за один персик до кількості купляємих персиків
func calculatePeachPrice(number int) float64 {
   // ...
}
```



