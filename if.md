# Умови

> Умови потрібні для того, що певні частини програми виконувались лише в зазначених випадках, таким чином змінюючи 
логіку програми в залежності від даних, котрими вона оперує

> Типовим прикладом умови є надання доступа до захищених частин сайту _якщо_ користувач має права адміністратора.

> Функцію умови в програмуванні виконує **оператор розгалуження** - `if`

В мові Go існує **булевий** тип даних (`bool`), яким може мати одно з двух значень:
```golang
yes := true
no := false
```

Змінні данного типу можуть бути створені вручну, як в прикладі вище, а також за допомогою наступних булевих **операторів**:
- над числовими значеннями `>` `<` `>=` `<=`
- над булевими значеннями `&&` `||` `!`
- універсальні `!=` `==`

> Звернімо увагу, що існують і інші типи операторів, наприклад математичні (`+`, `-`, `*` ітн)

Терміни:
- **Вираз** - будь-яке використання будь-якого оператора є виразом, наприклад `a > 0`, `x || y`, `s == "hello"`
- **Операнд** - значення або змінні які є членами виразу. Тобто в записі `b == 100`, `b` та `100` є операндами

### Оператори над числовими значеннями
Можуть бути використані лише разом з чисельними типами данних:
```golang
a := 10
b := 11
x := a < 11 // true
y := 10 > "anna" // panic! - так неможливо
```
В прикладі вище `a < 11` є виразом. Даний вираз під час виконання програми буде обчислений в значення `true` і дане значення буде записано в новостворену змінну з назвою `x`

Звернімо увагу, що приклад вище є показовим, але незмістовним. Читаючи реальну програму ми майже ніколи не зможемо зрозуміти наперед яким буде значення виразу. Наприклад:
```golang
var a int
var b int
fmt.Scanf(&a)
fmt.Scanf(&b)
x := a < b
fmt.Println(x)
```
Даний код демонструє, що змінна `x` може набувати різних значеня в залежності від того, що буде введено користувачем програми.

### Оператори над булевими значеннями

Може бути використаний лише з операндами булевого типу.

Оператор "Логічне АБО" - він буде обчислений в `true` коли хоча б один з його операндів має значення `true`:
```golang
a := true
b := false
fmt.Println(a || a) // true
fmt.Println(a || b) // true
fmt.Println(b || b) // false
// такий запис також можливий:
fmt.Println(a || b || false) // true
```

Оператор "Логічне І" буде обчислений в `true` лише коли обидва його операнди мають значення `true`:
```golang
a := true
b := false
fmt.Println(a && a) // true
fmt.Println(a && b) // false
fmt.Println(b && b) // false
```

Оператор "Логічне заперечення" змінює значення на протилежне:
```golang
yes := true
no := !yes
fmt.Println(no) // false
```

Оператори можуть бути комбіновані:
```golang
a := true
b := false
c := false
c := !(a || b) && (a || b || c)
```
Дужки в цьому випадку будуть відігравати таку саму роль, яку вони відіграють в математичних виразах, тобто роль пріорітета.

### Універсальні оператори
Універсальні оператори можуть бути використані з операндами будь-яких типів даних, але за умовою, що по обидві сторони від оператор знаходяться однакові типи даних:
```golang
a := "anna" == "anna" // true
b := 'c' == 'b' // false
c := 10 == 10 // true
d := "c" == 'c' // panic! - так неможливо
```

### Оператор `if`
Тип `bool` є невід'ємною частиною коли йдеть про умови в програмуванні, оскільки результат будь-якої умови це значення булевого типу.

Схематично оператор розгалуження записується наступним чином:
```
if БУЛЕВО ЗНАЧЕННЯ {
    ТІЛО УМОВИ
}
```
В цій схемі на місці БУЛЕВО ЗНАЧЕННЯ має бути або змінна, що має тип `bool`, або булевий вираз

Розглянемо декільки прикладів:
```golang
yes := true
if yes {
    fmt.Println("Yes!") // буде виконано
}
```

```golang
no := false
if !no {
    fmt.Println("Yes!") // буде виконано
}
```

Приклад з виразом:
```golang
a := 10
if a > 1 {
    fmt.Println("!") // буде виконано
}
```

Приклад вище буде ідентичним наступному:
```golang
a := 10
b := a > 1
if b {
    fmt.Println("!") // буде виконано
}
```

Ми також можемо комбінувати умови зі змінними:
```golang
a := true
b := 100
if a && b < 200 {
    fmt.Println("!") // буде виконано
}
```

Одним з типових сценарієв використання умов є надання різних значень змінній:
```golang
salary := 150
tax := 0.05
if salary > 100 && salary <= 200 {
    tax = 0.1
} else if salary > 200 && salary <= 300 {
    tax = 0.2
} else if salary > 300 {
    tax = 0.3
}
fmt.Println(tax)
```
Запис `else if` додає альтернативну для існуючої умову, котра буде виконана ЛИШЕ якщо попередня умова не справдилась.

В даному випадку програма виведе `0.1`, тобто спрацює перша умова, а інші дві навіть не будуть перевірені.

Якщо б ми записали `salary := 400`, то спочатку були би поступово виконані перші дві умови і лише після того як вони не справдились, третя умова була б вичислена в `true` (оскільки `400 > 300`) та було би виконано тіло даної гілки умови, тобто `tax = 0.3`.

Існує також можливість виконати певний блок без додаткових умов, якщо всі попередні умови не справдились:
```golang
hours := 22
var message string
if hours > 5 && hours < 21 {
    message = "It's day"
} else {
    message = "It's night"
}
fmt.Println(message)
```

Ще один приклад:
```golang
var pricePerOneApple float64
var numberOfApples := 117

if numberOfApples < 10 {
    pricePerOneApple = 4.20
} else if numberOfApples < 20 {
    numberOfApples = 3.90
} else if numberOfApples < 30 {
    numberOfApples = 3.30
} else {
    numberOfApples = 3.10
}
```
В даному прикладі виділено 4 можливі проміжки кількості яблук:
1) до 9
2) від 10 до 19
3) від 20 до 29
4) від 30 і більше

Не дивлячись на те, що ми ніде чітко не зазначаємо в другій умові, що кількість яблук має бути "від 10", ци випливає з визначення, що всі умови виконуються послідовно. Тобто, якщо перша умова (`numberOfApples < 10`) не справдилась, то значення `numberOfApples` в другій умові не може бути менше 10.

Подивимось на ще один приклад:
```golang
price := 4.40
numberOfApples := 117

if numberOfApples > 10 {
    price *= 0.97
}

if numberOfApples > 50 {
    price *= 0.94
}
```
В даній програмі ми маємо дві окремі умови (вони не пов'язані через `else if`), тому вони можуть бути виконані разом.

В цьому прикладі, оскільки `117 > 10` буде виконана перша умова і ціна буде знижена на 3%. Далі, оскільки `117 > 50` ціна буде зменшена ща на 6%.


### Оператор switch

Альтернативою для `if` є інший оператор `switch`, він може бути використаний замість `if` у випадках коли ми перевіряємо різні можливі варіанти для однієї змінної (або виразу)

Схематично це виглядає так:
```golang
switch ЗНАЧЕННЯ {
    case ПЕРШИЙ МОЖЛИВИЙ ВАРІАНТ ЗНАЧЕННЯ:
        БЛОК КОДА, ЩО БУДЕ ВИКОНАНИЙ ЯКЩО ЗНАЧЕНЯ ДОРІВНЮЄ ПЕРШОМУ МОЖЛИВОМУ ВАРІАНТУ ЗНАЧЕННЯ
    case ДРУГИЙ МОЖЛИВИЙ ВАРІАНТ ЗНАЧЕННЯ:
        БЛОК КОДА, ЩО БУДЕ ВИКОНАНИЙ ЯКЩО ЗНАЧЕНЯ ДОРІВНЮЄ ДРУГОМУ МОЖЛИВОМУ ВАРІАНТУ ЗНАЧЕННЯ
    default:
        БЛОК КОДА, ЩО БУДЕ ВИКОНАНИЙ ЯКЩО ВСІ МОЖЛИВІ ВАРІАНТИ НЕ ПІДІЙШЛИ
}
```
Тобто кожен блок `case` являє одну з можливих альтернатив для ЗНАЧЕННЯ. Таких блоків може бути безліч.

Приклад:
```golang
sex := ""
name := "anna"
switch name {
    case "anna":
        sex = "female"
    case "dmytro":
        sex = "male"
    case "ivan":
        sex = "male"
    default:
        sex = "unknown"
}
```
В даному прикладі буде виконаний `case "anna"` оскільки ЗНАЧЕННЯ (тобто `name`) буде дорівнювати "anna" і відповідно змінній `sex` буде присвоєно значення "female".

Якщо би ми виставили `name := "dmytro"`, то був би виконаний інший `case` і в результаті `sex` дорівнював би "male".

Якщо би ми виставили `name := "svetlana"`, то була би виконана інструкція `default`, що означало б що немає передбачених варіантів для даного значення.

Все те саме ми могли би записати за допомогою `if`, однак `switch` є просто більш наглядним.
```golang
sex := ""
name := "anna"
if name == "anna" {
    sex = "female"
} else if name == "dmytro" {
    sex = "male"
} else if name == "ivan" {
    sex = "male"
} else {
    sex = "unknown"
}
```

